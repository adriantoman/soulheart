#!/usr/bin/env ruby

$LOAD_PATH.unshift File.expand_path(File.dirname(__FILE__) + '/../lib')
begin
  require 'redis'
rescue LoadError
  require 'rubygems'
  require 'redis'
end
require 'soulmate'
require 'optparse'

parser = OptionParser.new do |opts|
  opts.banner = "Usage: soulmate [options] COMMAND"

  opts.separator ""
  opts.separator "Options:"

  opts.on("-r", "--redis [HOST:PORT]", "Redis connection string") do |host|
    Soulmate.redis = host
  end

  opts.on("-s", "--stop-words [FILE]", "Path to file containing a list of stop words") do |fn|
    File.open(fn) do |file|
      Soulmate.stop_words = file.readlines.map{ |l| l.strip }.reject{ |w| w.empty? }
    end
  end

  opts.on("-h", "--help", "Show this message") do
    puts opts
    exit
  end

  opts.separator ""
  opts.separator "Commands:"
  opts.separator "  load   TYPE FILE BATCH  Replaces collection specified by TYPE with items read from FILE in the JSON lines format, BATCH lines at a time (default of 10000)."
  opts.separator "  add    TYPE             Adds items to collection specified by TYPE read from stdin in the JSON lines format."
  opts.separator "  remove TYPE             Removes items from collection specified by TYPE read from stdin in the JSON lines format. Items only require an 'id', all other fields are ignored."
  opts.separator "  query  TYPE QUERY       Queries for items from collection specified by TYPE."
end

def load(type, file)
  if File.exists?(file)
    batch_size = ARGV[3].to_i.zero? ? 10000 : ARGV[3].to_i
    start_time = Time.now.to_i

    puts "Purging existing items of type #{type} ..."
    loader = Soulmate::Loader.new(type)
    loader.cleanup

    puts "Loading items of type #{type} in batches of #{batch_size} ..."
    count = 0
    begin
      f = File.open(file)
      while !f.eof?
        lines = []
        batch_size.times do
          break if f.eof?
          lines << MultiJson.decode(f.gets)
          count += 1
        end
        loader.load(lines)
        puts "Loaded #{count} items ..." unless f.eof?
      end
    ensure
      f.close
    end
    puts "Loaded a total of #{count} items in #{Time.now.to_i - start_time} second(s)"
  else
    puts "Couldn't open file: #{file}"
  end
end

def add(type)
  puts "Adding items of type #{type}..."
  loader = Soulmate::Loader.new(type)
  items = $stdin.read.split("\n").map { |l| MultiJson.decode(l) }
  items.each do |item|
    loader.add(item)
  end
  puts "Loaded a total of #{items.size} items"
end

def remove(type)
  puts "Removing items of type #{type}..."
  loader = Soulmate::Loader.new(type)
  items = $stdin.read.split("\n").map { |l| MultiJson.decode(l) }
  items.each do |item|
    loader.remove(item)
  end
  puts "Removed a total of #{items.size} items"
end

def query(type, query)
  puts "> Querying '#{type}' for '#{query}'"
  matcher = Soulmate::Matcher.new(type)
  results = matcher.matches_for_term(query, :limit => 0)
  results.each do |item|
    puts MultiJson.encode(item)
  end
  puts "> Found #{results.size} matches"
end

parser.parse!

case ARGV[0]
when 'load'
  load ARGV[1], ARGV[2]
when 'add'
  add ARGV[1]
when 'remove'
  remove ARGV[1]
when 'query'
  query ARGV[1], ARGV[2]
else
  puts parser.help
end
