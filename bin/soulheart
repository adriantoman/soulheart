#!/usr/bin/env ruby

$LOAD_PATH.unshift File.expand_path(File.dirname(__FILE__) + '/../lib')
begin
  require 'redis'
rescue LoadError
  require 'rubygems'
  require 'redis'
end
require 'soulheart'
require 'optparse'
require 'tempfile'

parser = OptionParser.new do |opts|
  opts.banner = 'Usage: soulheart [options] COMMAND'

  opts.separator ''
  opts.separator 'Options:'

  opts.on('-r', '--redis [HOST:PORT]', 'Redis connection string') do |host|
    Soulheart.redis = host
  end

  opts.on('-s', '--stop-words [FILE]', 'Path to file containing a list of stop words') do |fn|
    File.open(fn) do |file|
      Soulheart.stop_words = file.readlines.map(&:strip).reject(&:empty?)
    end
  end

  opts.on('-h', '--help', 'Show this message') do
    puts opts
    exit
  end

  opts.on('-b', '--batch-size', 'Number of lines to read at a time') do |size|
    BATCH_SIZE = size
  end

  opts.separator ''
  opts.separator 'Commands:'
  opts.separator '  load   TYPE FILE  Replaces collection specified by TYPE with items read from FILE in the JSON lines format.'
  opts.separator '  add    TYPE       Adds items to collection specified by TYPE read from stdin in the JSON lines format.'
  opts.separator "  remove TYPE       Removes items from collection specified by TYPE read from stdin in the JSON lines format. Items only require an 'id', all other fields are ignored."
  opts.separator '  query  TYPE QUERY Queries for items from collection specified by TYPE.'
end


def load(file)
  require 'uri'
  if file =~ URI.regexp
    require 'open-uri'
    f = open(file)
  elsif File.exist?(file)
    f = File.open(file)
  else
    puts "Couldn't open file: #{file}"
    return true
  end

  start_time = Time.now.to_i
  count = 0
  loader = Soulheart::Loader.new
  lines = []
  begin
    if file.match(/(c|t)sv\z/i)
      puts 'Reading a CSV'
      require 'csv'
      sep = file.match(/tsv\z/i) ? "\t" : ','
      CSV.foreach(f, headers: true, col_sep: sep) do |row|
        lines << row.to_hash
        count += 1
      end
    elsif file.match(/json\z/i)
      puts 'Reading JSON'
      puts "Loading items in batches of #{BATCH_SIZE} ..."
      until f.eof?
        lines = []
        BATCH_SIZE.times do
          break if f.eof?
          lines << MultiJson.decode(f.gets)
          count += 1
        end
      end
    else
      puts 'unknown File type'
    end
  ensure
    f.close
  end
  loader.load(lines)
  puts "Loaded a total of #{count} items in #{Time.now.to_i - start_time} second(s)"
end

def add(type)
  puts "Adding items of type #{type}..."
  loader = Soulheart::Loader.new(type)
  items = $stdin.read.split("\n").map { |l| MultiJson.decode(l) }
  items.each do |item|
    loader.add(item)
  end
  puts "Loaded a total of #{items.size} items"
end

def remove(type)
  puts "Removing items of type #{type}..."
  loader = Soulheart::Loader.new(type)
  items = $stdin.read.split("\n").map { |l| MultiJson.decode(l) }
  items.each do |item|
    loader.remove(item)
  end
  puts "Removed a total of #{items.size} items"
end

def query(type, query)
  puts "> Querying '#{type}' for '#{query}'"
  matcher = Soulheart::Matcher.new(type)
  results = matcher.matches_for_term(query, limit: 0)
  results.each do |item|
    puts MultiJson.encode(item)
  end
  puts "> Found #{results.size} matches"
end

def gen_redis_proto(*cmd)
  proto = '*' + cmd.length.to_s + "\r\n"
  cmd.each{|arg|
    proto << '$' + arg.bytesize.to_s + "\r\n"
    proto << arg + "\r\n"
  }
  proto
end

parser.parse!
BATCH_SIZE ||= 1000

case ARGV[0]
when 'generate'
  generate ARGV[1], ARGV[2]
when 'load'
  load ARGV[1]
when 'add'
  add ARGV[1]
when 'remove'
  remove ARGV[1]
when 'query'
  query ARGV[1], ARGV[2]
else
  puts parser.help
end
